'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var lib = require('@web-std/file');
var test$1 = require('./test.cjs');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

var lib__namespace = /*#__PURE__*/_interopNamespace(lib);

/**
 * @param {import('./test').Test} test
 */
const test = test => {
  test("test baisc", async () => {
    test$1.assert.isEqual(typeof lib__namespace.Blob, "function");
    test$1.assert.isEqual(typeof lib__namespace.File, "function");
  });

  if (globalThis.window === globalThis) {
    test("uses built-ins", async () => {
      test$1.assert.isEqual(lib__namespace.File, globalThis.File);
      test$1.assert.isEqual(lib__namespace.Blob, globalThis.Blob);
    });
  }

  test("new File", async () => {
    // @ts-expect-error
    test$1.assert.throws(() => new lib.File(), TypeError);
    // @ts-expect-error
    test$1.assert.throws(() => new lib.File([]), TypeError);

    const before = Date.now();
    await new Promise(resolve => setTimeout(resolve, 3));
    const file = new lib.File(["test"], "name");
    await new Promise(resolve => setTimeout(resolve, 3));
    const after = Date.now();
    test$1.assert.equal(file.size, 4);
    test$1.assert.equal(file.name, "name");
    test$1.assert.equal(typeof file.lastModified, "number");
    test$1.assert.equal(file.lastModified > before, true);
    test$1.assert.equal(file.lastModified < after, true);
    test$1.assert.equal(file.type, "");

    const chunks = [];
    const reader = file.stream().getReader();
    while (true) {
      const chunk = await reader.read();
      if (chunk.done) {
        reader.releaseLock();
        break
      } else {
        chunks.push(chunk.value);
      }
    }

    test$1.assert.deepEqual(chunks, [new TextEncoder().encode("test")]);
  });

  test("File with lastModified", async () => {
    const file = new lib.File(["test"], "name", { lastModified: 1594672000418 });

    test$1.assert.equal(file.size, 4);
    test$1.assert.equal(file.name, "name");
    test$1.assert.equal(file.lastModified, 1594672000418);
    test$1.assert.equal(file.type, "");
  });

  test("File with type", async () => {
    const file = new lib.File(["test"], "name", {
      lastModified: 1594672000418,
      type: "text/plain",
    });

    test$1.assert.equal(file.size, 4);
    test$1.assert.equal(file.name, "name");
    test$1.assert.equal(file.lastModified, 1594672000418);
    test$1.assert.equal(file.type, "text/plain");
  });

  test("File type is normalized", async () => {
    const file = new lib.File(["test"], "name", {
      type: "Text/Plain",
    });

    test$1.assert.equal(file.size, 4);
    test$1.assert.equal(file.name, "name");
    test$1.assert.equal(file.type, "text/plain");
  });

  test("File name is (not) escaped", async () => {
    const file = new lib.File(["test"], "dir/name");

    test$1.assert.equal(file.size, 4);
    // occording to spec it's former but in pratice it seems later ü§∑‚Äç‚ôÇÔ∏è
    test$1.assert.equal(file.name === "dir:name" || file.name === "dir/name", true);
    test$1.assert.equal(file.type, "");
  });
};

exports.test = test;
//# sourceMappingURL=file.spec.cjs.map
